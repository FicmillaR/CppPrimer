<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>变量和基本类型1 - CppPrimer学习笔记</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="..">CppPrimer学习笔记</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="..">Home</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../ch01%20%E5%BC%80%E5%A7%8B/">ch01 开始</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">ch02 变量和基本类型</a>
    <ul class="dropdown-menu">
            
<li class="active">
    <a href="./">变量和基本类型1</a>
</li>
            
<li >
    <a href="../ch02%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B_2/">变量和基本类型2</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../ch03%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/">ch03 字符串、向量和数组</a>
</li>
                            
<li >
    <a href="../ch04%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/">ch04 表达式</a>
</li>
                            
<li >
    <a href="../ch05%20%E8%AF%AD%E5%8F%A5/">ch05 语句</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">ch06 函数</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../ch06%20%E5%87%BD%E6%95%B0_1/">函数1</a>
</li>
            
<li >
    <a href="../ch06%20%E5%87%BD%E6%95%B0_2/">函数2</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../ch07%20%E7%B1%BB/">ch07 类</a>
</li>
                            
<li >
    <a href="../ch08%20IO%E5%BA%93/">ch08 IO库</a>
</li>
                            
<li >
    <a href="../ch09%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">ch09 顺序容器</a>
</li>
                            
<li >
    <a href="../ch10%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">ch10 泛型算法</a>
</li>
                            
<li >
    <a href="../ch11%20%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">ch11 关联容器</a>
</li>
                            
<li >
    <a href="../ch12%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">ch12 动态内存</a>
</li>
                            
  <li class="dropdown-submenu">
    <a href="#">ch13 拷贝控制</a>
    <ul class="dropdown-menu">
            
<li >
    <a href="../ch13%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6_1/">拷贝控制1</a>
</li>
            
<li >
    <a href="../ch13%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6_2/">拷贝控制2</a>
</li>
    </ul>
  </li>
                            
<li >
    <a href="../ch14%20%E6%93%8D%E4%BD%9C%E9%87%8D%E8%BD%BD%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">ch14 操作重载与类型转换</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">CheatSheet <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../cheatsheet/static%E7%9A%843%E4%B8%AA%E7%94%A8%E9%80%94/">static的3个用途</a>
</li>
                            
<li >
    <a href="../cheatsheet/%E8%8B%A5%E5%B9%B2%E7%A7%8Dtypedef/">若干种typedef</a>
</li>
                            
<li >
    <a href="../cheatsheet/%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%80%BC/">类内初始值</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../ch01%20%E5%BC%80%E5%A7%8B/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../ch02%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B_2/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/demon90s/CppPrimer">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#1">变量和基本类型1</a></li>
            <li><a href="#_1">基本内置类型</a></li>
            <li><a href="#_5">变量</a></li>
            <li><a href="#_10">复合类型</a></li>
            <li><a href="#const">const限定符</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="1"><center>变量和基本类型1</center></h1>
<hr />
<h2 id="_1">基本内置类型</h2>
<p>C++定义了一套包括<strong>算术类型</strong>（arithmetic type）和<strong>空类型</strong>（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，如可作为函数的返回值。</p>
<h3 id="_2">算术类型</h3>
<p>算术类型分为整型和浮点型。</p>
<p>算术类型的尺寸（所占比特数）在不同机器上有所差别。C++标准规定了尺寸的最小值，编译器允许赋予这些类型更大的尺寸。某一类型所占的比特数不同，它所能表示的数据范围也不一样。</p>
<p>算术类型尺寸表格见书本p30。</p>
<p>布尔类型（bool）的取值是true或者false。</p>
<p>浮点型可表示单精度、双精度和扩展精度值。一般来说，类型float和double分别有7和16个有效位，float以1个字（32比特）来表示，double以2个字（64比特）来表示。</p>
<p><strong>带符号类型和无符号类型</strong></p>
<p>除去布尔类型和扩展的字符型之外，其它整型可以划分为<strong>带符号的</strong>（signed）和<strong>无符号的</strong>（unsigned）两种。带符号类型可以表示正数、负数或0，无符号类型仅能表示大于等于0的值。</p>
<p>与其他整型不同，字符型被分成了三种：char、signed char和unsigned char。类型char会表现为上述形式中的一种，具体是哪种由编译器决定。</p>
<blockquote>
<p>my_note: 在GCC上测试，char是有符号的。</p>
</blockquote>
<p>选择类型的一些经验准则：</p>
<ul>
<li>
<p>当明确知晓数值不可能为负时，选用无符号类型。</p>
</li>
<li>
<p>使用int执行整数运算，如果数值超过了int的表示范围，选用long long。</p>
</li>
<li>
<p>在算术表达式中不要使用char或bool。因为char在不同机器上的表现方式不一样。</p>
</li>
<li>
<p>执行浮点数运算选用double。因为double精度更高，且运算代价和float没有相差无几。</p>
</li>
</ul>
<h3 id="_3">类型转换</h3>
<p>对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数类型支持，就是将对象从一种给定的类型<strong>转换</strong>（convert）为另一种相关类型。</p>
<p>当在程序的某处我们使用了一种类型而其实对象应该取另一种类型时，程序会自动进行类型转换。</p>
<p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li>
<p>当把非bool的算术值赋给bool类型时，初始值为0则结果为false，否则结果为true。</p>
</li>
<li>
<p>当把bool值赋给非bool类型时，初始值为false则结果为0，初始值为true则结果为1。</p>
</li>
<li>
<p>当把一个浮点数赋给整数类型时，结果值将仅保留浮点数中小数点之前的部分。</p>
</li>
<li>
<p>当把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度有可能损失。</p>
</li>
<li>
<p>当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</p>
</li>
<li>
<p>当我们赋给带符号类型一个超出它表示范围的值时，结果是<strong>未定义的</strong>（undefined）。此时，程序可能继续工作、可能崩溃、也可能生成垃圾数据。</p>
</li>
</ul>
<p><strong>含有无符号类型的表达式</strong></p>
<p>提示：切勿混用带符号类型和无符号类型。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。</p>
<h3 id="_4">字面值常量</h3>
<p>一个形如42的值被称作字面值常量（literal），这样的值一望便知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p>
<p><strong>整型和浮点型字面值</strong></p>
<p>我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式。以0开头的整数代表八进制数，以0x或0X开头的代表十六进制数。例如，我们能用下面的任意一种形式来表示数值20：</p>
<p><code>20 /* 十进制 */</code>    <code>024 /* 八进制 */</code>    <code>0x14 /* 十六进制 */</code></p>
<p>十进制字面值的类型是int、long和long long中尺寸最小的那个。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小者。</p>
<p>浮点型字面值表现为一个小数或以科学计数法表示的指数，其指数部分用E或e标识：</p>
<p>3.14159 3.14159E0    0.    0e0    .001</p>
<p>默认的，浮点型字面值是一个double。</p>
<blockquote>
<p>my note: GCC下，像20这样的十进制整数字面值，类型是int</p>
</blockquote>
<p><strong>字符和字符串字面值</strong></p>
<p>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串字面值。</p>
<p>'a'    // 字符字面值
"a"    // 字符串字面值</p>
<p>字符串字面值的类型实际上是由常量字符构成的数组（array）。编译器在每个字符串的结尾处添加一个空字符（'\0'），因此，字符串字面值的实际长度要比它的内容多1。</p>
<p><strong>转义序列</strong></p>
<p>有两类字符程序员不能直接使用：一类是<strong>不可打印</strong>（nonprintable）字符，如退格或其他控制字符；另一类是有特殊含义的字符，如引号、问号、反斜线。这些情况下需要用到<strong>转义序列</strong>（escape sequence），转义序列以反斜线作为开始。</p>
<p>转义序列见书本p36。</p>
<p><strong>指定字面值的类型</strong></p>
<p>通过添加一些前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。</p>
<p>这些前缀和后缀见书本p37。</p>
<p><strong>布尔字面值和指针字面值</strong></p>
<p>true和false是布尔类型的字面值。</p>
<h2 id="_5">变量</h2>
<p>变量提供一个具名、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。</p>
<h3 id="_6">变量定义</h3>
<p>变量定义的基本形式是：首先是<strong>类型说明符</strong>（type specifier），随后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。列表中每个变量名的类型由类型说明符指定，定义时还可以为一个或多个变量赋初值：</p>
<pre><code>int sum = 0, value = 0;
</code></pre>

<p><strong>术语：何为对象？</strong></p>
<p>通常情况下，对象是指一块能存储数据并具有某种类型的内存空间。</p>
<p><strong>初始值</strong></p>
<p>当对象在创建时获得了一个特定的值，我们说这个对象被<strong>初始化</strong>（initialized）了。</p>
<p>【WARNING】：初始化不是赋值，初始化的含义是创建变量时赋予一个初始值，而赋值的含义是把对象当前值擦除，而以一个新值替代。</p>
<p><strong>列表初始化</strong></p>
<p>要想定义一个名为units_sold的int变量并初始化为0，以下4条语句都可以做到这一点：</p>
<pre><code>int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
</code></pre>

<p>作为C++11新标准的一部分，用花括号来初始化变量得到了全面应用。这种初始化的形式被称为<strong>列表初始化</strong>（list initialization）。</p>
<p>当用于内置类型的变量时，这种初始化形式有一个重要特点，如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。</p>
<blockquote>
<p>my note: 在我的GCC 4.8.5下面，这种情况会报warning。</p>
</blockquote>
<p><strong>默认初始化</strong></p>
<p>如果定义变量时没有指定初值，则变量被<strong>默认初始化</strong>（default initialized）。</p>
<p>如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。定义于函数体之外的变量被初始化为0。定义在函数体内部的内置类型变量将<strong>不被初始化</strong>（uninitialized）。一个未被初始化的内置类型变量的值是未定义的。</p>
<p>每个类各自决定其初始化对象的方式。</p>
<p>【TIP】建议初始化每一个内置类型的变量。</p>
<h3 id="_7">变量声明和定义的关系</h3>
<p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式编译（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。</p>
<p>为了支持分离式编译，C++语言将声明和定义区分开来。<strong>声明</strong>（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义</strong>负责创建与名字关联的实体。</p>
<p>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显示初始化变量：</p>
<pre><code>extern int i;    // 声明i而非定义i
int j;           // 声明并定义j
</code></pre>

<p>任何包含了显式初始化的声明即成为定义。</p>
<p>【NOTE】变量能且只能被定义一次，但是可以被多次声明。</p>
<h3 id="_8">标识符</h3>
<p>C++的标识符（identifier）由字母、数字和下画线组成，其中必须以字母或下画线开头。标识符的长度没有限制，但是对大小写敏感。</p>
<p>C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。见书本p43。</p>
<p>同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
<h3 id="_9">名字的作用域</h3>
<p>不论是在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。</p>
<p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++语言中大多数作用域都以花括号分隔。</p>
<p>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</p>
<p>名字main定义于所有花括号之外，它和其他大多数定义在函数体之外的名字一样拥有<strong>全局作用域</strong>（global scope）。一旦声明后，全局作用域内的名字在整个程序的范围内都可使用。</p>
<blockquote>
<p>my note: 在花括号内定义的变量拥有块作用域。for语句内定义的名字，只能在for语句之内访问。</p>
</blockquote>
<p><strong>嵌套的作用域</strong></p>
<p>作用域能彼此包含，被包含的作用域称为<strong>内层作用域</strong>（inner scope），包含着别的作用域的作用域称为<strong>外层作用域</strong>（outer scope）。</p>
<p>作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字。</p>
<h2 id="_10">复合类型</h2>
<p>复合类型（compound type）是指基于其他类型定义的类型。</p>
<h3 id="_11">引用</h3>
<p><strong>引用</strong>（reference）为对象起了另外一个名字。通过将声明符写成&amp;d的形式来定义引用类型，其中d是声明的变量名：</p>
<pre><code>int ival = 1024;
int &amp;refVal = ival;    // refVal指向ival（是ival的另一个名字）
</code></pre>

<p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</p>
<p>【NOTE】引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p>
<p>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
<h3 id="_12">指针</h3>
<p><strong>指针</strong>（pointer）是“指向”另外一种类型的复合类型。指针本身就是一个对象，允许对指针赋值和拷贝。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</p>
<p>定义指针类型的方法将声明符写成*d的形式，其中d是变量名。如果在一条语句中定义了几个指针变量，每个变量的前面都必须有符号*。</p>
<pre><code>int *p1, *p2;    // p1和p2都是指向int型对象的指针
</code></pre>

<p><strong>获取对象的地址</strong></p>
<p>指针存放某个对象的地址，要想获取该地址，需要使用取地址符（操作符&amp;）：</p>
<pre><code>int ival = 42;
int *p = &amp;ival; // p存放变量ival的地址，或者说p是指向变量ival的指针
</code></pre>

<p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p>
<p>通常，所有指针的类型都要和它所指的对象严格匹配。</p>
<pre><code>double dval;
double *pd = &amp;dval;    // 正确，初始值是double型对象的地址

int *pi = pd;          // 错误，指针pi的类型和pd的类型不匹配
</code></pre>

<p><strong>指针值</strong></p>
<p>指针的值（即地址）应属下列4种状态之一：</p>
<p>0. 指向一个对象。</p>
<p>0. 指向紧邻对象所占用空间的下一个位置。</p>
<p>0. 空指针，意味着指针没有指向任何对象。</p>
<p>0. 无效指针，也就是上述情况之外的其他值。</p>
<p><strong>利用指针访问对象</strong></p>
<p>如果指针指向了一个对象，则允许使用<strong>解引用符</strong>（操作符*）来访问对象：</p>
<pre><code>int ival = 42;
int *p = &amp;ival;
cout &lt;&lt; *p;    // 由符号*得到指针p所指的对象，输出42
</code></pre>

<p>【NOTE】解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>
<p><strong>空指针</strong></p>
<p><strong>空指针</strong>（null pointer）不指向任何对象。以下列出几个生成空指针的方法：</p>
<pre><code>int *p1 = nullptr;    // 等价于 int *p1 = 0
int *p2 = 0;
// 需要首先#include &lt;cstdlib&gt;
int *p3 = NULL;
</code></pre>

<p><strong>void*指针</strong></p>
<p>void*是一种特殊的指针类型，可用于存放任意对象的地址。</p>
<p>利用void*指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void*指针。不能直接操作void*所指的对象。</p>
<h3 id="_13">理解复合类型的声明</h3>
<p>变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同：</p>
<pre><code>// i是一个int型的数，p是一个指向int型的指针，r是一个int型的引用
int i = 1024, *p = &amp;i, &amp;r = i;
</code></pre>

<p>【WARNING】很多程序员容易迷惑于基本数据类型和类型修饰符之间的关系，其实后者不过是声明符的一部分罢了。</p>
<p>【TIP】面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。</p>
<h2 id="const">const限定符</h2>
<p>有时我们希望定义这样一种变量，它的值不能被改变。为了满足这一要求，可以用关键字<strong>const</strong>对变量的类型加以限定：</p>
<pre><code>const int bufSize = 512;
</code></pre>

<p>这样就把bufSize定义成了一个常量。任何试图为bufSize赋值的行为都将引发错误。</p>
<p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p>
<p><strong>默认情况下，const对象仅在文件内有效</strong></p>
<p>当以编译时初始化的方式定义一个const对象时，就如对bufSize的定义一样：</p>
<pre><code>const int bufSize = 512;
</code></pre>

<p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。</p>
<p>为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p>
<p>【NOTE】如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。</p>
<h3 id="const_1">const的引用</h3>
<p>把引用绑定到const对象上，称之为对<strong>常量的引用</strong>（reference to const）。</p>
<pre><code>const int a = 1024;
const int &amp;r = a;
</code></pre>

<p>对常量的引用不能修改它所绑定的对象的值。</p>
<p><strong>初始化和对const的引用</strong></p>
<p>引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p>
<pre><code>int i = 42;
const int &amp;r1 = i;    // 允许将const int&amp;绑定到一个普通int对象上
const int &amp;r2 = 42;   // 正确：r1是一个常量引用
const int &amp;r3 = r1 * 2; // 正确：r3是一个常量引用
int &amp;r4 = r1 * 2;     // 错误：r4是一个普通的非常量引用
</code></pre>

<p><strong>对const的引用可能引用一个并非const的对象</strong></p>
<p>必须认识到，常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p>
<h3 id="const_2">指针和const</h3>
<p><strong>指向常量的指针</strong>（pointer to const）不能改变其所指对象的值。想要存放常量对象的地址，只能使用指向常量的指针：</p>
<pre><code>const double pi = 3.14;
const double *p = &amp;pi;
</code></pre>

<p>指针的类型必须与其所指对象的类型一致，但是有两个例外。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：</p>
<pre><code>double dval = 3.14;
cptr = &amp;dval;    // 正确，但是不能通过cptr改变dval的值
</code></pre>

<p><strong>const指针</strong></p>
<p>指针是一个对象，可以把它定义成const的，叫<strong>常量指针</strong>（const pointer）。把*放在const关键字之前用以说明指针是一个常量：</p>
<pre><code>int n = 0;
int *const p = &amp;n;
</code></pre>

<h3 id="const_3">顶层const</h3>
<p>顶层const（top-level const）表示指针本身是一个常量。</p>
<p>底层const(low-level const)表示指针所指对象是一个常量。</p>
<p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const。</p>
<pre><code>int i = 0;
int *const p1 = &amp;i;    // 不能改变p1的值，p1是一个顶层const
const int ci = 42；    // 不能改变ci的值，ci是一个顶层const
const int *p2 = &amp;ci;   // 允许改变p2的值，p2是一个底层const
const int *const p3 = p2; // 靠右的const是顶层const，靠左的是底层const
const int &amp;r = ci;     // 用于声明引用的const都是底层const
</code></pre>

<h3 id="constexpr">constexpr和常量表达式</h3>
<p><strong>常量表达式</strong>（const expression）是指值不会改变，且在编译过程中就能得到计算结果的表达式。</p>
<p>这些都是常量表达式：</p>
<ul>
<li>
<p>字面值</p>
</li>
<li>
<p>用常量表达式初始化的const对象</p>
</li>
</ul>
<p><strong>constexpr变量</strong></p>
<p>用const定义的变量并不一定是常量表达式，因此要换一种方法定义常量表达式。</p>
<p>C++11标准提供了constexpr关键字，让编译器验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<pre><code>constexpr int mf = 20;    // 20是常量表达式
constexpr int limit = mf + 1;    // mf + 1是常量表达式
constexpr int sz = size();    // 只有当size是一个constexpr函数时，才是一条正确的声明语句
</code></pre>

<p><strong>字面值类型</strong></p>
<p>在编译时就能得到计算，类型比较简单，值也显而易见的类型，叫<strong>字面值类型</strong>（literal type）。</p>
<p>算术类型，引用，指针都属于字面值类型。</p>
<p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<p><strong>指针和constexpr</strong></p>
<p>如果在constexpr声明中定义了一个指针，那么它只对指针有效，与指针所指的对象无关：</p>
<pre><code>const int *p = nullptr;      // p是一个指向常量的指针
constexpr int *p2 = nullptr; // p2是一个常量指针
</code></pre>

<p>与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：</p>
<pre><code>int j = 0;
constexpr int i = 42;
// i和j都必须定义在函数体外
constexpr const int *p = &amp;i;    // p是常量指针，指向整型常量i
constexpr int *p1 = &amp;j;         // p1是常量指针，指向整数j
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
